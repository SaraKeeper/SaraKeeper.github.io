<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    BearCat
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="SaraKeeper" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Bear-Cat</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li><a class="category-link" href="/categories/%E8%A7%84%E8%8C%83/">规范</a></li><li><a class="category-link" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/SaraKeeper" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="paw" href="http://zhangyipengpeng.fun" target="_blank" rel="noopener">
                            <i class="icon fa fa-paw"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="book" href="http://eojhelper.fun" target="_blank" rel="noopener">
                            <i class="icon fa fa-book"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/images/thumbs/java_interview.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >八股基础</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="第一章-Java语言基础"><a href="#第一章-Java语言基础" class="headerlink" title="第一章 Java语言基础"></a><b>第一章 Java语言基础</b></h2><p>&nbsp;<br>怎么理解 $Java$ 的跨平台？<br>&nbsp;<br>程序运行之前，会把程序员编写的 $Java$ 源代码（即 $.java$ 文件）用编译器编译成字节码（即 $.class$ 文件），然后由 $JVM$ （$Java$ 虚拟机）负责将字节码翻译为特定机器的机器指令。<br>同一份源代码，经过编译得到的字节码是相同的，只要拿着这份字节码到不同平台（如 $Windows, Linus$），$JVM$ 都能执行，这就是所谓的”一次编译、到处运行“，也就是 $Java$ 的跨平台特性。</p>
<p>&nbsp;<br>$Java$ 中类的访问权限？<br>&nbsp;<br>$private$：修饰的对象只能在所在的类中访问；<br>$protected$：修饰的对象只能在所在的类、或者同一包的其他类中访问；<br>$public$：没有限制，项目中的任意包，任意类都可以访问；<br>$default$：不加任何修饰词时，默认 $protected$ 。</p>
<p>&nbsp;<br>怎么理解 $Java$ 的面向对象？<br>&nbsp;<br>面向对象和面向过程是两种程序设计方法，实践证明现今较大型的程序使用面向对象更优（代码可读性、可维护性、逻辑解耦性）。<br>面向对象的三大特征是封装、继承、多态。<br>封装指的是将对象的实现细节用 $private$ 方法隐藏起来，用 $public$ 方法暴露实际的功能；<br><img style="width:30%;" src="/img/java_interview/1.3.1.png"><br>继承的作用是代码复用，子类继承父类后自动获得父类的属性和方法；<br>多态指的是子类对象可以直接赋值给父类变量，因为子类可以重写父类的方法，这时父类变量执行方法时执行的是子类的逻辑，不同的父类变量被不同的子类对象继承重写后，可以表现出不同的行为特征，这样父类对象就展示出了多态性。<br><img style="width:20%;" src="/img/java_interview/1.3.2.png"></p>
<p>&nbsp;<br>$Java$ 的八种基本数据类型？<br>&nbsp;<br>整数：$byte$ 、$short$ 、$int$ 、$long$ ；<br>浮点：$float$ 、$double$ ；<br>字符：$char$ ；<br>布尔：$boolean$ 。</p>
<p>&nbsp;<br>$Java$ 的变量类型？<br>&nbsp;<br>$Java$ 因为是完全面向对象的语言，所以没有严格意义上的全局变量，变量分为成员变量和局部变量两种。<br>成员变量：属于类实例的变量，每次创建对象时生成一个，有默认初始值（整数浮点是零，字符是 $Unicode$ 编码的第零个字符，布尔是假）；<br>局部变量：在类方法中定义的变量，每次调用方法时生成一个，没有默认初始值。</p>
<p>&nbsp;<br>$Java$ 的自动装拆箱？<br>&nbsp;<br>指的是八种基本数据类型分别对应一个”装箱类型“，如 $Byte$ 、$Integer$ 、$Double$ 等。<br>装箱变量和基本类型比较时，会转为基本类型再比较，如 $Integer$ 和 $int$ 比较时，会先将 $Integer$ 转为 $int$ 。</p>
<p>&nbsp;<br>$Java$ 中重写和重载的区别？<br>&nbsp;<br>重载发生在同一个类中，指的是不同的方法方法名相同，但参数的个数或类型不同，重载的方法都生效，都能正常使用；<br><img style="width:30%;" src="/img/java_interview/1.7.1.png"><br>重写发生在继承的父子类中，如果子类用 $@Override$ 注解重写了父类的方法（方法名以及参数个数类型完全一致），那么调用时会使用子类的逻辑（重写可以表现出面向对象的多态性，可以看前面的 $Fruit$ 类），被重写的父类逻辑在子类中就失效了。</p>
<p>&nbsp;<br>$equals()$ 、$==$ 和 $hashCode()$ 的关系。<br>&nbsp;<br>每个对象都有继承自 $Object$ 类的 $equals()$ 方法和 $hashCode()$ 方法，默认情况下 $equals()$ 和 $==$ 比较的对象在 $Java$ 虚拟机中的地址，$hashCode()$ 也返回对象在虚拟机中的地址。<br>但有些情况下，需要我们赋予对象相等的新的定义（比如两个 $Book$ 类，图书编号相同就认为相等），这时候可以重写 $equals()$ 方法实现。<br>但是 $HashSet$ 、$HashMap$ 等数据结构在判断两个对象是否相同时，会先比较 $hashCode()$ ，如果哈希码不等就直接认为不同，相等才比较 $equals()$ 。<br>所以我们约定，只要重写了 $equals()$ ，就要重写 $hashCode()$ ，使得二者逻辑上是一样的，避免未来无意间产生 $bug$ 。</p>
<p>&nbsp;<br>$ArrayList$ 和 $LinkedList$ 的区别？<br>&nbsp;<br>顾名思义，$ArrayList$ 是类似数组的线性结构，$LinkedList$ 是类似链表的线性结构，因此：<br>第一，在查找效率上，数组只要使用下标 $O(1)$ 查到，而链表要从头指针向后 $O(n)$ 查到；而在插入删除效率上，数组要用 $O(n)$ 移动对应位置之后的全部元素，而链表通过指针的赋值只要用 $O(1)$ 完成。<br>第二，空间效率上，因为 $LinkedList$ 要存每个元素的指针，所以比 $ArrayList$ 占用更大的存储空间。<br>总言之，$ArrayList$ 查找比增删的效率高，适合变更比较少的场景；而 $LinkedList$ 增删比查找的效率高，适合查找比较少的场景；如果增删和查找的比重差不多，在省空间的考量下优先选择 $ArrayList$ 。</p>
<p>&nbsp;<br>$HashMap$ 和 $HashTable$ 的区别？<br>&nbsp;<br>两者都是 $Map&lt;key,value&gt;$ 的数据结构，主要有以下区别：<br>第一，$HashMap$ 是非线程安全的，比如多个线程同时操作 $HashMap$ 可能导致数据不一致，而 $HashTable$ 是线程安全的。<br>第二，$HashMap$ 的 $key$ 和 $value$ 都可以是 $Null$（当然 $Null$ 作为 $key$ 时最多一个），而 $HashTable$ 不允许 $key$ 或 $value$ 为 $Null$ ，否则会抛出 $NullPointerException$ 空指针异常。<br>总言之，单线程的场景一般用 $HashMap$ ，多线程的场景也不用 $HashTable$ ，而是用 $JDK1.8$ 版本后的 $ConcurrentHashMap$ 。</p>
<p>&nbsp;<br>$ConcurrentHashMap$ 和 $HashTable$ 的区别？<br>&nbsp;<br>二者都是线程安全的，但有以下不同：<br>第一，$HashTable$ 实现线程安全的方式是线程修改数据时加锁锁住整个 $HashTable$ ，效率低，而 $ConcurrentHashMap$ 把整个 $Map$ 分成 $N$ (默认 $16$)个 $Segment$ ，一些操作只要锁住一些 $Segment$ 而不用锁住整张表，所以效率更高。<br>第二，二者初始化时都只分配较小的空间，然后通过数据增长动态扩容的，$HashTable$ 初始 $size$ 为 $11$ ，每次扩容都是整张表大小乘二加一，而 $ConcurrentHashMap$ 是在每个 $Segment$ 达到容量百分之 $75$ 时扩容，不用整张表扩容。<br>正因为如此，$HashTable$ 正在被 $ConcurrentHashTable$ 所取代。</p>
<p>&nbsp;   </p>
<h2 id="第二章-操作系统"><a href="#第二章-操作系统" class="headerlink" title="第二章 操作系统"></a><b>第二章 操作系统</b></h2><p>&nbsp;<br>并发和并行的区别？<br>&nbsp;<br>并发指的是一个系统同时遇到多条任务，就像一个办事窗口处理多条队伍，窗口可以依次选择队伍的第一个人办事。<br>并行指的是多个系统在相同时间同时分别处理自己的任务，就像两个办事窗口各排一条队，分别办理自己的队伍。<br>在并发中，每个队伍就是一个任务，系统可以把每个队伍分到的时间拆的很小（每个队伍执行很短的时间就暂停，先执行下一个队伍，轮一圈再轮到自己），这样宏观上三个队伍在”同时“执行，但实际上同一时间只有一个队伍在被处理；而并行中，是真正的”同时“进行，同一时间有多个任务在被执行。</p>
<p>&nbsp;<br>进程和线程的区别？<br>&nbsp;<br>一个线程属于一个进程，一个进程可以包含多个线程；<br>线程挂了，对应的进程也挂了，一个进程挂了，不会影响其他进程；<br>线程是 $CPU$ 调度的最小单位，进程是系统资源调度的最小单位；<br>线程需要的系统资源更少，开销显著小于进程；<br>进程和线程的通信方式也不一样。</p>
<p>&nbsp;<br>进程之间如何通信？<br>&nbsp;<br>匿名管道：管道都是半双工，一般在父子进程间使用；<br>命名管道：因为匿名管道没有名字，只能在父子进程间通信，为了克服这个缺点，提出了命名管道；<br>信号：硬件产生（如除以零、无效的存储访问等）、软件产生（如下 $kill$ 某个进程）、键盘输入（如按下 $Ctrl+C$ 产生退出信号 $SIGINT$）；<br>消息队列：消息队列和管道一样可以先进先出，但消息队列也可以按消息类型出队；<br>共享内存：两个进程共享一块双方可访问的内存空间；<br>信号量：初始设为资源数目，$P$ 操作减一，$V$ 操作加一，当减为零时 $P$ 操作会被堵塞；<br>套接字：$Socket$ 在不同主机间进行进程通信，套接字 = $IP$ 地址 + 端口号。</p>
<p>&nbsp;<br>进程使用共享内存的优势（相比其他通信方式）？<br>&nbsp;<br>主要是效率高，举个例子：<br>管道、消息队列等需要四次数据拷贝，因为它们在操作系统的内核中（发起进程→内存→内核中的管道→内存→接受进程）；<br>而共享内存只要两次（发起进程→内存中的共享内存→接收进程）。</p>
<p>&nbsp;<br>线程之间如何通信？<br>&nbsp;<br>锁机制：如读写锁、互斥锁；<br>信号量机制：类似进程的信号量，包括匿名和命名两种；<br>信号机制：主要用于线程同步。</p>
<p>&nbsp;<br>使用多线程可能带来什么问题？<br>&nbsp;<br>性能降低和死锁。<br>操作系统在线程间切换要额外消耗时间，导致性能降低；<br>多线程会互相等待对方，都不能往下执行，导致死锁。</p>
<p>&nbsp;<br>什么是线程死锁？如何解决？<br>&nbsp;<br>两个线程分别占用了对方想要的资源而不释放，又分别在等待对方释放资源，导致都不能往下执行，就产生了死锁。<br>可以加锁解决，对两个线程共享的资源加锁，一个线程使用时另一个线程就无法操作，就不会出现”持有并等待“。</p>
<p>&nbsp;<br>线程的生命周期和状态变化？<br>&nbsp;<br>新建、就绪、运行、阻塞、死亡。<br>$new$ 操作创建线程对象时，线程处于新建状态；<br>线程对象执行 $start()$ 方法时，变为就绪状态；<br>线程对象执行 $run()$ 方法时，变为运行状态；<br>进入阻塞状态有多种情况，如调用 $sleep()$ 方法，操作系统分配的时间片到期等；<br>在阻塞结束时，会重新进入就绪状态；<br>进入死亡状态也有多种情况，如正常执行结束、抛出异常等。<br><img style="width:40%;" src="/img/java_interview/2.4.1.png"></p>
<p>&nbsp;   </p>
<h2 id="第三章-计算机网络"><a href="#第三章-计算机网络" class="headerlink" title="第三章 计算机网络"></a><b>第三章 计算机网络</b></h2><p>&nbsp;<br>七层网络体系结构？<br>&nbsp;<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<p>&nbsp;<br>五层网络体系结构以及常见的协议？<br>&nbsp;<br>应用层：直接为用户的进程提供服务，包括 $HTTP$ 协议（网页传输）、$SMTP$ 协议（邮件传输）、$FTP$ 协议（文件传输）、$DNS$ 协议（域名映射到 $IP$）等；<br>运输层：负责两个主机之间的进程的通信，包括 $TCP$ 协议（面向连接，可靠）、$UDP$ 协议（无连接，不保证可靠，效率更高）；<br>网络层：负责为分组交换网上的不同主机的通信，包括 $IP$ 协议；<br>数据链路层；<br>物理层。</p>
<p>&nbsp;<br>介绍一下 $TCP$ 的三次握手？<br>&nbsp;<br>第一次：建立连接时，客户端发送 $syn=x$ 包到服务器，进入 $SYN_SENT$ 状态等待服务器确认；<br>第二次：服务端收到 $syn$ 包后，发回确认包 $ack=x+1$ ，同时发送一个 $syn=y$ 包，进入 $SYN_RECV$ 状态；<br>第三次：客户端收到服务器的两个包，向服务器发送确认包 $ack=y+1$ ，发送完后客户端和服务端都进入 $ESTABLISHED$ 状态。<br>简言之，客户端发起、服务端确认、客户端确认服务端能够连接，共三步。</p>
<p>&nbsp;<br>介绍一下 $TCP$ 的四次挥手，为什么比三次握手要多一次报文发送？<br>&nbsp;<br>第一次：客户端发送连接释放报文（$FIN=1,seq=u$），进入 $FIN-WAIT-1$ 状态；<br>第二次：服务端收到后，发回确认报文（$ACK=1,ack=u+1,seq=v$），进入 $CLOSE_WAIT$ 状态，客户端收到确认报文后，进入 $FIN-WAIT-2$ 状态，等待连接释放报文；<br>第四次：服务端在数据传输完毕后，发送连接释放报文（$FIN=1,ack=u+1$），客户端收到后，再经过两倍报文寿命的时间后，发送确认报文（$ACK=1,seq=u+1,ack=w+1$）并关闭连接，客户端收到后也关闭连接。<br>简言之，客户端发起，服务端确认，服务端关闭，客户端确认，共四步。<br>之所以要多花一步，是因为关闭连接前仍有数据传输，服务端确认和服务端关闭之间要保证数据都传输完毕，而三次握手没有数据传输，中间两次合成一次发送了。</p>
<p>&nbsp;<br>从浏览器输入一个网址并回车开始，到最终看到网页，中间发生了什么？</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
